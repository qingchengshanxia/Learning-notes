查看MongoDB是否启动： cmd输入services.msc     在弹出窗找到MongoDB，点击启动


第二种MongoDB启动方法：D:/mongodb/bin>mongod --dbpath D:\mongodb\data\db


是否启动成功，打开http://localhost:27017查看，如果有下列英文表示启动成功：It looks like you are trying to access MongoDB over HTTP on the native driver port.


开始菜单右键，找到‘命令提示符（管理员）’，可以以管理员权限打开cmd；


一般互联网公司多用mysql,redis,mongodb做存储层，hadoop,spark做大数据分析：
    'mysql'适合结构化数据，类似excel表格一样定义严格的数据，用于数据量中，速度一般支持事务处理场合。
    'redis'适合缓存内存对象，如缓存队列，用于数据量小，速度快不支持事务处理高并发场合。
    'mongodb'适合半结构化数据，如文本信息，用于数据量大，速度较快不支持事务处理场合。
    'hadoop'是个生态系统，上面有大数据分析很多组件，适合事后大数据分析任务。
    'spark'类似hadoop，偏向于内存计算，流计算，适合实时半实时大数据分析任务。




MongoDB简介：
    MongoDB 是一个基于'分布式文件存储'的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。
    MongoDB 是一个介于'关系数据库'和'非关系数据库'之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。



NoSQL简介:
    NoSQL(NoSQL = Not Only SQL )，意即"不仅仅是SQL"，是对不同于传统的'关系型数据库'的数据库管理系统的统称。
    NoSQL，指的是非关系型的数据库。
    在现代的计算系统上每天网络上都会产生庞大的数据量,这些数据有很大一部分是由'关系数据库管理系统'（RDMBSs）来处理。关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。

    为什么使用NoSQL ?
        今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了,NoSQL数据库的发展也却能很好的处理这些大的数据。

    RDBMS vs NoSQL
        RDBMS
        - 高度组织化结构化数据
        - 结构化查询语言（SQL） (SQL)
        - 数据和关系都存储在单独的表中。
        - 数据操纵语言，数据定义语言
        - 严格的一致性
        - 基础事务
        NoSQL
        - 代表着不仅仅是SQL
        - 没有声明性查询语言
        - 没有预定义的模式
        - 键 - 值对存储，列存储，文档存储，图形数据库
        - 最终一致性，而非ACID属性
        - 非结构化和不可预知的数据
        - CAP定理
        - 高性能，高可用性和可伸缩性

    NoSQL的优点/缺点
        优点:
        - 高可扩展性
        - 分布式计算
        - 低成本
        - 架构的灵活性，半结构化数据
        - 没有复杂的关系
        缺点:
        - 没有标准化
        - 有限的查询功能（到目前为止）
        - 最终一致是不直观的程序


    CAP定理（CAP theorem）
        在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer's theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:
            一致性(Consistency) (所有节点在同一时间具有相同的数据)
            可用性(Availability) (保证每个请求不管成功或者失败都有响应)
            分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)
        CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。
        因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：
            CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。
            CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。
            AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。

    BASE
        BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。
        CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。
        BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:
            Basically Availble --基本可用
            Soft-state --软状态/柔性事务。 "Soft state" 可以理解为"无连接"的, 而 "Hard state" 是"面向连接"的
            Eventual Consistency --最终一致性 最终一致性， 也是是 ACID 的最终目的。



关系型数据库遵循ACID规则:
    事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：
    1、A (Atomicity) 原子性
        就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。
        比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。
    2、C (Consistency) 一致性
        就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。
    3、I (Isolation) 独立性
        所谓的独立性,是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。
        比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。
    4、D (Durability) 持久性
        持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。





分布式系统
    分布式系统（distributed system）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。
    分布式系统是建立在网络之上的软件系统。
    正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。
    因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。
    分布式系统可以应用在不同的平台上如：Pc、工作站、局域网和广域网上等。

    分布式计算的优点
        可靠性（容错） ：
        分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。
        可扩展性：
        在分布式计算系统可以根据需要增加更多的机器。
        资源共享：
        共享数据是必不可少的应用，如银行，预订系统。
        灵活性：
        由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。
        更快的速度：
        分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。
        开放系统：
        由于它是开放的系统，本地或者远程都可以访问到该服务。
        更高的性能：
        相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。


    分布式计算的缺点
        故障排除：
        故障排除和诊断问题。
        软件：
        更少的软件支持是分布式计算系统的主要缺点。
        网络：
        网络基础设施的问题，包括传输问题，高负载，信息丢失等。
        安全性：
        开发系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。




MongoDB的存储特点
    MongoDB 将数据存储为一个文档,数据结构由键值(key=>value)对组成。
    MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。

    主要特点
        MongoDB的提供了一个面向文档存储，操作起来比较简单和容易。
        你可以在MongoDB记录中设置任何属性的索引 (如：FirstName="Sameer",Address="8 Gandhi Road")来实现更快的排序。
        你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。
        如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。
        Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。
        MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。
        Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。
        Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。
        Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。
        GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。
        MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。
        MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。
        MongoDB安装简单。




数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。
        不能是空字符串（"")。
        不得含有' '（空格)、.、$、/、\和\0 (空字符)。
        应全部小写。
        最多64字节。



        有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。
            admin： 从权限的角度来看，这是"root"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。
            local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合
            config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。


use local   ==>  在mongondb中的mongo.exe中输入该命令，可以切换到名字为local的数据库；

    db   ==>  列出当前连接的数据库

show dbs   ===> 列出所有的数据库

show collections   ===> 列出当前数据库所有的集合






mongodb中基本的概念是文档、集合、数据库：
        SQL术语/概念        MongoDB术语/概念        解释/说明
        database            database                数据库
        table               collection              数据库表/集合
        row                 document                数据记录行/文档
        column              field                   数据字段/域
        index               index                   索引
        table               joins                   表连接,MongoDB不支持
        primary key         primary key             主键,MongoDB自动将_id字段设置为主键



文档
    文档是一组键值(key-value)对(即BSON)。
    MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。
    一个简单的文档例子如下：
    {"site":"www.runoob.com", "name":"菜鸟教程"}



    下表列出了 RDBMS 与 MongoDB 对应的术语：
        RDBMS          MongoDB
        数据库         数据库
        表格           集合
        行             文档
        列             字段
        表联合         嵌入文档
        主键           主键 (MongoDB 提供了 key 为 _id )

        数据库服务和客户端
        Mysqld/Oracle   mongod
        mysql/sqlplus   mongo


    需要注意的是：
        文档中的键/值对是有序的。
        文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。
        MongoDB区分类型和大小写。
        MongoDB的文档不能有重复的键。
        文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。

    文档键命名规范：
        键不能含有\0 (空字符)。这个字符用来表示键的结尾。
        .和$有特别的意义，只有在特定环境下才能使用。
        以下划线"_"开头的键是保留的(不是严格要求的)。




集合
    集合就是 MongoDB 文档组，类似于 RDBMS 中的表格。
    集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。

    这是一个集合：
        {"site":"www.baidu.com"}
        {"site":"www.google.com","name":"Google"}
        {"site":"www.runoob.com","name":"菜鸟教程","num":5}

    当第一个文档插入时，集合就会被创建。

    合法的集合名：
        集合名不能是空字符串""。
        集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。
        集合名不能以"system."开头，这是为系统集合保留的前缀。
        用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。



    capped collections：
        Capped collections 就是固定大小的collection。
        它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 "RRD" 概念类似。
        Capped collections是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能 和标准的collection不同，你必须要显式的创建一个capped collection， 指定一个collection的大小，单位是字节。collection的数据存储空间值提前分配的。
        要注意的是指定的存储大小包含了数据库的头信息。　

        例如：
            db.createCollection("mycoll", {capped:true, size:100000})

        在capped collection中，你能添加新的对象。
        能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。
        数据库不允许进行删除。使用drop()方法删除collection所有的行。
        注意: 删除之后，你必须显式的重新创建这个collection。
        在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。



    元数据：
        数据库的信息是存储在集合中。它们使用了系统的命名空间：dbname.system.*

        在MongoDB数据库中名字空间 <dbname>.system.* 是包含多种系统信息的特殊集合(Collection)，如下:
            集合命名空间                  描述
            dbname.system.namespaces        列出所有名字空间。
            dbname.system.indexes           列出所有索引。
            dbname.system.profile           包含数据库概要(profile)信息。
            dbname.system.users             列出所有可访问数据库的用户。
            dbname.local.sources            包含复制对端（slave）的服务器信息和状态。

        对于修改系统集合中的对象有如下限制：
            在{{system.indexes}}插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。
            {{system.users}}是可修改的。 {{system.profile}}是可删除的。



MongoDB 数据类型：
    数据类型            描述
    String              字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。
    Integer             整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。
    Boolean             布尔值。用于存储布尔值（真/假）。
    Double              双精度浮点值。用于存储浮点值。
    Min/Max keys        将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。
    Array               用于将数组或列表或多个值存储为一个键。
    Timestamp           时间戳。记录文档修改或添加的具体时间。
    Object              用于内嵌文档。
    Null                用于创建空值。
    Symbol              符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。
    Date                日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。
    Object ID           对象 ID。用于创建文档的 ID。
    Binary Data         二进制数据。用于存储二进制数据。
    Code                代码类型。用于在文档中存储 JavaScript 代码。
    Regular expression  正则表达式类型。用于存储正则表达式。





可以使用 MongoDB shell 来连接 MongoDB 服务器。
    标准 URI 连接语法：
        mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]

        mongodb:// 这是固定的格式，必须要指定。
        username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库
        host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。
        portX 可选的指定端口，如果不填，默认为27017
        /database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。
        ?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&或;（分号）隔开

    实例：
        使用默认端口来连接 MongoDB 的服务。
        mongodb://localhost


    使用用户 admin 使用密码 123456 连接到本地的 MongoDB 服务上。输出结果如下所示：
        > mongodb://admin:123456@localhost/
        ...
    使用用户名和密码连接登陆到指定数据库，格式如下：
        mongodb://admin:123456@localhost/test



    （以下操作都在mongo.exe中执行）
    MongoDB 创建数据库的语法格式如下：
        use DATABASE_NAME
        如果数据库不存在，则创建数据库，否则切换到指定数据库。

        刚创建的数据库 DATABASE_NAME 并不在数据库的列表中， 要显示它，我们需要向 DATABASE_NAME 数据库插入一些数据。
        > db.DATABASE_NAME.insert({"name":"菜鸟教程"})
            WriteResult({ "nInserted" : 1 })
        > show dbs
            local   0.000GB
            DATABASE_NAME  0.000GB
            test    0.000GB



    MongoDB 删除数据库的语法格式如下：
        db.dropDatabase()

        删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名,然后使用use database 切换到想要删除的数据库，然后用db.dropDatabase()删除，然后用show dbs查看所有的数据库，看该数据库是否被删除。


    MongoDB 删除集合：
        集合删除语法格式如下：
            db.collection.drop()
        以下实例删除了 runoob 数据库中的集合 site：
            > use runoob
            switched to db runoob
            > show tables
            site
            > db.site.drop()
            true
            > show tables
            >




    BSON格式：
        所有存储在Mongodb集合中的数据都是BSON格式。
        BSON是一种类json的一种'二进制形式'的存储格式,简称Binary JSON。


    插入文档
        MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下：
        db.COLLECTION_NAME.insert(document)
    实例
        以下文档可以存储在 MongoDB 的 runoob 数据库 的 col 集合中：
            >db.col.insert({
                title: 'MongoDB 教程',
                description: 'MongoDB 是一个 Nosql 数据库',
                by: '菜鸟教程',
                url: 'http://www.runoob.com',
                tags: ['mongodb', 'database', 'NoSQL'],
                likes: 100
            })
    以上实例中 col 是我们的集合名，如果该集合不在该数据库中， MongoDB 会自动创建该集合并插入文档。


    可以将数据定义为一个变量，然后将变量插入到数据库中：
        > document=({title: 'MongoDB 教程',
            description: 'MongoDB 是一个 Nosql 数据库',
            by: '菜鸟教程',
            url: 'http://www.runoob.com',
            tags: ['mongodb', 'database', 'NoSQL'],
            likes: 100
        });

        > db.col.insert(document)
            WriteResult({ "nInserted" : 1 })


    插入文档你也可以使用 db.col.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。


    3.2 版本后还有以下几种语法可用于插入文档:
         db.collection.insertOne():向指定集合中插入一条文档数据
         db.collection.insertMany():向指定集合中插入多条文档数据
            #  插入单条数据

            > var document = db.collection.insertOne({"a": 3})
            > document
            {
                    "acknowledged" : true,
                    "insertedId" : ObjectId("571a218011a82a1d94c02333")
            }

            #  插入多条数据
            > var res = db.collection.insertMany([{"b": 3}, {'c': 4}])
            > res
            {
                    "acknowledged" : true,
                    "insertedIds" : [
                            ObjectId("571a22a911a82a1d94c02337"),
                            ObjectId("571a22a911a82a1d94c02338")
                    ]
            }




    MongoDB 更新文档：
        MongoDB 使用 update() 和 save() 方法来更新集合中的文档。

        update() 方法
            update() 方法用于更新已存在的文档。语法格式如下：
                db.collection.update(
                   <query>,
                   <update>,
                   {
                     upsert: <boolean>,
                     multi: <boolean>,
                     writeConcern: <document>
                   }
                )

            参数说明：
                query : update的查询条件，类似sql update查询内where后面的。
                update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的
                upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。
                multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。
                writeConcern :可选，抛出异常的级别。

            通过 update() 方法来更新标题(title):
                >db.col.update({'title':'MongoDB 教程'},{$set:{'title':'MongoDB'}})
                    WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })   # 输出信息
                > db.col.find().pretty()
                    {
                            "_id" : ObjectId("56064f89ade2f21f36b03136"),
                            "title" : "MongoDB",
                            "description" : "MongoDB 是一个 Nosql 数据库",
                            "by" : "菜鸟教程",
                            "url" : "http://www.runoob.com",
                            "tags" : [
                                    "mongodb",
                                    "database",
                                    "NoSQL"
                            ],
                            "likes" : 100
                    }

            以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。
                >db.col.update({'title':'MongoDB 教程'},{$set:{'title':'MongoDB'}},{multi:true})


    findAndModify():
            它是原子性的，会'返回'符合查询条件的更新后的文档。
            一次最多只更新一个文档，也就是条件query条件，且执行sort后的第一个文档。
            db.COLLECTION_NAME.findAndModify({
                query:{},
                update:{},
                remove:true|false,
                new:true|false,
                sort:{},
                fields:{},
                upsert:true|false
            });

            query:是查询选择器，与findOne的查询选择器相同
            update:是要更新的值，不能与remove同时出现
            remove:表示删除符合query条件的文档，不能与update同时出现
            new为true：返回更新后的文档，false：返回更新前的，默认是false
            sort：排序条件，与sort函数的参数一致。
            fields:投影操作，与find*的第二个参数一致。
            upsert:与update的upsert参数一样。


    save() 方法
        save() 方法通过传入的文档来替换已有文档。语法格式如下：
            db.collection.save(
               <document>,
               {
                 writeConcern: <document>
               }
            )

        参数说明：
            document : 文档数据。
            writeConcern :可选，抛出异常的级别。

            以下实例中我们替换了 _id 为 56064f89ade2f21f36b03136 的文档数据：
                >db.col.save({
                    "_id" : ObjectId("56064f89ade2f21f36b03136"),
                    "title" : "MongoDB",
                    "description" : "MongoDB 是一个 Nosql 数据库",
                    "by" : "Runoob",
                    "url" : "http://www.runoob.com",
                    "tags" : [
                            "mongodb",
                            "NoSQL"
                    ],
                    "likes" : 110
                })



    更多实例
        只更新第一条记录：
        db.col.update( { "count" : { $gt : 1 } } , { $set : { "test2" : "OK"} } );
        全部更新：
        db.col.update( { "count" : { $gt : 3 } } , { $set : { "test2" : "OK"} },false,true );
        只添加第一条：
        db.col.update( { "count" : { $gt : 4 } } , { $set : { "test5" : "OK"} },true,false );
        全部添加加进去:
        db.col.update( { "count" : { $gt : 5 } } , { $set : { "test5" : "OK"} },true,true );
        全部更新：
        db.col.update( { "count" : { $gt : 15 } } , { $inc : { "count" : 1} },false,true );
        只更新第一条记录：
        db.col.update( { "count" : { $gt : 10 } } , { $inc : { "count" : 1} },false,false );


    在3.2版本开始，MongoDB提供以下更新集合文档的方法：
        db.collection.updateOne() 向指定集合更新单个文档
        db.collection.updateMany() 向指定集合更新多个文档

        首先我们在test集合里插入测试数据
            use test：
                db.test_collection.insert( [
                    {"name":"abc","age":"25","status":"zxc"},
                    {"name":"dec","age":"19","status":"qwe"},
                    {"name":"asd","age":"30","status":"nmn"},
                ] )
            更新单个文档：
                > db.test_collection.updateOne({"name":"abc"},{$set:{"age":"28"}})
                    { "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
                > db.test_collection.find()
                    { "_id" : ObjectId("59c8ba673b92ae498a5716af"), "name" : "abc", "age" : "28", "status" : "zxc" }
                    { "_id" : ObjectId("59c8ba673b92ae498a5716b0"), "name" : "dec", "age" : "19", "status" : "qwe" }
                    { "_id" : ObjectId("59c8ba673b92ae498a5716b1"), "name" : "asd", "age" : "30", "status" : "nmn" }
                >
            更新多个文档：
                > db.test_collection.updateMany({"age":{$gt:"10"}},{$set:{"status":"xyz"}})
                    { "acknowledged" : true, "matchedCount" : 3, "modifiedCount" : 3 }
                > db.test_collection.find()
                    { "_id" : ObjectId("59c8ba673b92ae498a5716af"), "name" : "abc", "age" : "28", "status" : "xyz" }
                    { "_id" : ObjectId("59c8ba673b92ae498a5716b0"), "name" : "dec", "age" : "19", "status" : "xyz" }
                    { "_id" : ObjectId("59c8ba673b92ae498a5716b1"), "name" : "asd", "age" : "30", "status" : "xyz" }
                >




    MongoDB 删除文档：
        MongoDB remove()函数是用来移除集合中的数据。
        MongoDB数据更新可以使用update()函数。在执行remove()函数前先执行find()命令来判断执行的条件是否正确，这是一个比较好的习惯。


        MongoDB 是 2.6 版本以后的，语法格式如下：
            db.collection.remove(
               <query>,
               {
                 justOne: <boolean>,
                 writeConcern: <document>
               }
            )

            参数说明：
                query :（可选）删除的文档的条件。
                justOne : （可选）如果设为 true 或 1，则只删除一个文档。
                writeConcern :（可选）抛出异常的级别。


            remove() 方法已经过时了，现在官方推荐使用 deleteOne() 和 deleteMany() 方法。

            如删除集合下全部文档：
                db.collection.deleteMany({})
            删除 status 等于 A 的全部文档：
                db.collection.deleteMany({ status : "A" })
            删除 status 等于 D 的一个文档：
                db.collection.deleteOne( { status: "D" } )



    MongoDB 查询文档:
        MongoDB 查询文档使用 find() 方法。
        find() 方法以非结构化的方式来显示所有文档。
        除了 find() 方法之外，还有一个 findOne() 方法，它只返回一个文档。

        MongoDB 查询数据的语法格式如下：
            db.collection.find(query, projection)  ---> 一行一行的显示
            query ：可选，使用查询操作符指定查询条件
            projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。

        如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：
            >db.col.find().pretty()
            pretty() 方法以格式化的方式来显示所有文档。


        MongoDB 的条件语句查询：
            操作          格式                         范例
            等于          {<key>:<value>}              db.col.find({"by":"菜鸟教程"}).pretty()
            小于          {<key>:{$lt:<value>}}        db.col.find({"likes":{$lt:50}}).pretty()
            小于或等于    {<key>:{$lte:<value>}}       db.col.find({"likes":{$lte:50}}).pretty()
            大于          {<key>:{$gt:<value>}}        db.col.find({"likes":{$gt:50}}).pretty()
            大于或等于    {<key>:{$gte:<value>}}       db.col.find({"likes":{$gte:50}}).pretty()
            不等于        {<key>:{$ne:<value>}}        db.col.find({"likes":{$ne:50}}).pretty()


        MongoDB AND 条件
            db.col.find({key1:value1, key2:value2}).pretty()  --->json格式显示
            类似于 WHERE 语句：WHERE by='菜鸟教程' AND title='MongoDB 教程'

        MongoDB OR 条件
            MongoDB OR 条件语句使用了关键字 $or,语法格式如下：
            db.col.find({$or: [{key1: value1}, {key2:value2}]}).pretty()


        MongoDB AND和OR 条件
            db.col.find({key1:value1, $or: [{key1: value1}, {key2:value2}]}).pretty()




MongoDB 条件操作符:
        条件操作符用于比较两个表达式并从mongoDB集合中获取数据。

        MongoDB中条件操作符有：
            (>) 大于 - $gt
            (<) 小于 - $lt
            (>=) 大于等于 - $gte
            (<= ) 小于等于 - $lte





$type 操作符:
        $type操作符是基于BSON类型来检索集合中匹配的'数据类型'，并返回结果。


        类型                      数字              备注
        Double                      1
        String                      2
        Object                      3
        Array                       4
        Binary data                 5
        Undefined                   6              已废弃。
        Object id                   7
        Boolean                     8
        Date                        9
        Null                        10
        Regular Expression          11
        JavaScript                  13
        Symbol                      14
        JavaScript (with scope)     15
        32-bit integer              16
        Timestamp                   17
        64-bit integer              18
        Min key                     255             Query with -1.
        Max key                     127

        示例：
            如果想获取 "col" 集合中 title 为 String 的数据，你可以使用以下命令：
            db.col.find({"title" : {$type : 2}})



     Limit() 方法：
         如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。

             语法：
                limit()方法基本语法如下所示：
             >db.COLLECTION_NAME.find().limit(NUMBER)

             实例：
                 > db.col.find({},{"title":1,_id:0}).limit(2)
                 { "title" : "PHP 教程" }
                 { "title" : "Java 教程" }
             >
             补充说明：
                第一个 {} 放 where 条件，为空表示返回集合中所有文档。
                第二个 {} 指定那些列显示和不显示 （0表示不显示 1表示显示)。


     Skip() 方法：
         来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。

             语法：
                skip() 方法脚本语法格式如下：
                >db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)

             实例：
             以上实例只会显示第二条文档数据
                >db.col.find({},{"title":1,_id:0}).limit(1).skip(1)
                { "title" : "Java 教程" }
                >
             注:skip()方法默认参数为 0 。
             （当查询时同时使用sort,skip,limit，无论位置先后，最先执行顺序 sort再skip再limit。）



    想要读取从 10 条记录后 100 条记录，相当于 sql 中limit (10,100)。
        > db.COLLECTION_NAME.find().skip(10).limit(100)
        以上实例在集合中跳过前面 10 条返回 100 条数据。

    注意：
        skip 和 limit 结合就能实现分页。
        当查询时同时使用sort,skip,limit，无论位置先后，最先执行顺序 sort再skip再limit。
        补充说明skip和limit方法只适合小数据量分页，如果是百万级效率就会非常低，因为skip方法是一条条数据数过去的，建议使用where_limit




    sort()方法：
        在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，
        其中 1 为升序排列，而-1是用于降序排列。

            语法：
                sort()方法基本语法如下所示：
                    >db.COLLECTION_NAME.find().sort({KEY:1})

            实例：
                >db.col.find({},{"title":1,_id:0}).sort({"likes":-1})
                { "title" : "PHP 教程" }
                { "title" : "Java 教程" }
                { "title" : "MongoDB 教程" }



    MongoDB 索引：
        索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。
        这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。
        索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构

        ensureIndex() 方法：
            MongoDB使用 ensureIndex() 方法来创建索引。

            语法：
                ensureIndex()方法基本语法格式如下所示：
                    >db.COLLECTION_NAME.ensureIndex({KEY:1})
                语法中 Key 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。

            实例：
                >db.col.ensureIndex({"title":1})

                ensureIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。
                >db.col.ensureIndex({"title":1,"description":-1})


            ensureIndex() 接收可选参数，可选参数列表如下：
            Parameter           Type            Description
            background          Boolean         建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，
                                                即增加 "background" 可选参数。 "background" 默认值为false。

            unique              Boolean         建立的索引是否唯一。指定为true创建唯一索引。默认值为false.
            name                string          索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。
            dropDups            Boolean         在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.
            sparse              Boolean         对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，
                                                在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.

            expireAfterSeconds  integer         指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。
            v                   index version   索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。
            weights             document        索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。
            default_language    string          对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语
            language_override   string          对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，
                                                默认值为 language.

            实例：
                在后台创建索引：
                    db.values.ensureIndex({open: 1, close: 1}, {background: true})
                通过在创建索引时加background:true 的选项，让创建工作在后台执行



    MongoDB 聚合：
        MongoDB中聚合(aggregate)主要用于处理数据(诸如统计'平均值/求和'等)，并返回计算后的数据结果。

        aggregate() 方法：
            MongoDB中聚合的方法使用aggregate()。

        语法：
            aggregate() 方法的基本语法格式如下所示：
            >db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)

            示例：现在我们通过以上集合计算每个作者所写的文章数，使用aggregate()计算结果如下：
                > db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : 1}}}])
                {
                   "result" : [
                      {
                         "_id" : "runoob.com",
                         "num_tutorial" : 2
                      },
                      {
                         "_id" : "Neo4j",
                         "num_tutorial" : 1
                      }
                   ],
                   "ok" : 1
                }


            示例：
            db.articles.aggregate({
                $project : {
                    title: 2,
                    by_user: 1,
                }
            })
            这样子也是可行的。也就是说非0也可以进行表示显示该字段,负数也可以表示显示该字段。



        聚合的表达式:
            表达式               描述
            $sum                计算总和。
            实例：db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$sum : "$likes"}}}])

            $avg                计算平均值
            实例：db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$avg : "$likes"}}}])

            $min                获取集合中所有文档对应值得最小值。
            实例：db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$min : "$likes"}}}])

            $max                获取集合中所有文档对应值得最大值。
            实例：db.mycol.aggregate([{$group : {_id : "$by_user", num_tutorial : {$max : "$likes"}}}])

            $push               在结果文档中插入值到一个数组中。
            实例：db.mycol.aggregate([{$group : {_id : "$by_user", url : {$push: "$url"}}}])

            $addToSet           在结果文档中插入值到一个数组中，但不创建副本。
            实例：db.mycol.aggregate([{$group : {_id : "$by_user", url : {$addToSet : "$url"}}}])

            $first              根据资源文档的排序获取第一个文档数据。
            实例：db.mycol.aggregate([{$group : {_id : "$by_user", first_url : {$first : "$url"}}}])

            $last               根据资源文档的排序获取最后一个文档数据
            实例：db.mycol.aggregate([{$group : {_id : "$by_user", last_url : {$last : "$url"}}}])



            管道的概念：
                管道在Unix和Linux中一般用于将'当前命令的输出结果'作为'下一个命令的参数'。
                MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。
                    表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。
                    聚合框架常用操作：
                        $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。
                        $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。
                        $limit：用来限制MongoDB聚合管道返回的文档数。
                        $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。
                        $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。
                        $group：将集合中的文档分组，可用于统计结果。
                        $sort：将输入文档排序后输出。
                        $geoNear：输出接近某一地理位置的有序文档。
            管道操作符实例
            1、$project实例
            db.article.aggregate(
                { $project : {
                    title : 1 ,
                    author : 1 ,
                }}
             );
            这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样:
            db.article.aggregate(
                { $project : {
                    _id : 0 ,
                    title : 1 ,
                    author : 1
                }});
            2.$match实例
            db.articles.aggregate( [
                                    { $match : { score : { $gt : 70, $lte : 90 } } },
                                    { $group: { _id: null, count: { $sum: 1 } } }
                                   ] );
            $match用于获取分数大于70小于或等于90记录，然后将符合条件的记录送到下一阶段$group管道操作符进行处理。
            3.$skip实例
            db.article.aggregate(
                { $skip : 5 });
            经过$skip管道操作符处理后，前五个文档被"过滤"掉。



        按日、按月、按年、按周、按小时、按分钟聚合操作如下：
            db.getCollection('m_msg_tb').aggregate(
            [
                {$match:{m_id:10001,mark_time:{$gt:new Date(2017,8,0)}}},
                {$group: {
                       _id: {$dayOfMonth:'$mark_time'},
                        pv: {$sum: 1}
                    }
                },
                {$sort: {"_id": 1}}
            ])
            时间关键字如下：
             $dayOfYear: 返回该日期是这一年的第几天（全年 366 天）。
             $dayOfMonth: 返回该日期是这一个月的第几天（1到31）。
             $dayOfWeek: 返回的是这个周的星期几（1：星期日，7：星期六）。
             $year: 返回该日期的年份部分。
             $month： 返回该日期的月份部分（ 1 到 12）。
             $week： 返回该日期是所在年的第几个星期（ 0 到 53）。
             $hour： 返回该日期的小时部分。
             $minute: 返回该日期的分钟部分。
             $second: 返回该日期的秒部分（以0到59之间的数字形式返回日期的第二部分，但可以是60来计算闰秒）。
             $millisecond：返回该日期的毫秒部分（ 0 到 999）。
             $dateToString： { $dateToString: { format: , date: } }。




    MongoDB 复制（副本集）:
        MongoDB复制是将数据同步在多个服务器的过程。
        复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。
        复制还允许您从硬件故障和服务中断中恢复数据。


        什么是复制?
            保障数据的安全性
            数据高可用性 (24*7)
            灾难恢复
            无需停机维护（如备份，重建索引，压缩）
            分布式读取数据


        MongoDB复制原理
            mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。
            mongodb各个节点常见的搭配方式为：一主一从、一主多从。
            主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。

            原理：客户端从主节点读取数据，在客户端写入数据到主节点时， 主节点与从节点进行数据交互保障数据的一致性。

            副本集特征：
                N 个节点的集群
                任何节点可作为主节点
                所有写入操作都在主节点上
                自动故障转移
                自动恢复


            MongoDB副本集设置：
                1、关闭正在运行的MongoDB服务器。
                    现在我们通过指定 --replSet 选项来启动mongoDB。--replSet 基本语法格式如下：
                        mongod --port "PORT" --dbpath "YOUR_DB_DATA_PATH" --replSet "REPLICA_SET_INSTANCE_NAME"
                    实例：
                        mongod --port 27017 --dbpath "D:\set up\mongodb\data" --replSet rs0
                        以上实例会启动一个名为rs0的MongoDB实例，其端口号为27017。
                        启动后打开命令提示框并连接上mongoDB服务。
                        在Mongo客户端使用命令rs.initiate()来启动一个新的副本集。
                        我们可以使用rs.conf()来查看副本集的配置
                        查看副本集状态使用 rs.status() 命令

                副本集添加成员：
                    添加副本集的成员，我们需要使用多台服务器来启动mongo服务。进入Mongo客户端，并使用rs.add()方法来添加副本集的成员。
                    语法：
                        rs.add() 命令基本语法格式如下：
                        >rs.add(HOST_NAME:PORT)
                    实例：
                        假设你已经启动了一个名为mongod1.net，端口号为27017的Mongo服务。 在客户端命令窗口使用rs.add() 命令将其添加到副本集中，命令如下所示：
                            >rs.add("mongod1.net:27017")
                        MongoDB中你只能通过主节点将Mongo服务添加到副本集中， 判断当前运行的Mongo服务是否为主节点可以使用命令db.isMaster() 。
                        MongoDB的副本集与我们常见的主从有所不同，主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。



    MongoDB 分片：
        在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。
        当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。


        为什么使用分片
            复制所有的写入操作到主节点
            延迟的敏感数据会在主节点查询
            单个副本集限制在12个节点
            当请求量巨大时会出现内存不足。
            本地磁盘不足
            垂直扩展价格昂贵

        分片实例
        分片结构端口分布如下：
            Shard Server 1：27020
            Shard Server 2：27021
            Shard Server 3：27022
            Shard Server 4：27023
            Config Server ：27100
            Route Process：40000

        步骤一：启动Shard Server

        步骤二： 启动Config Server

        步骤三： 启动Route Process

        步骤四： 配置Sharding

        步骤五： 程序代码内无需太大更改，直接按照连接普通的mongo数据库那样，将数据库连接接入接口40000



    MongoDB数据备份：
        在Mongodb中我们使用mongodump命令来备份MongoDB数据。该命令可以导出所有数据到指定目录中。
        mongodump命令可以通过'参数'指定导出的数据量级转存的服务器。

        语法：
            mongodump命令脚本语法如下：
                >mongodump -h dbhost -d dbname -o dbdirectory

        -h：
            MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017
        -d：
            需要备份的数据库实例，例如：test
        -o：
            备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。

        实例：
        在本地使用 27017 启动你的mongod服务。打开命令提示符窗口，进入MongoDB安装目录的bin目录输入命令mongodump:
            >mongodump
        执行以上命令后，客户端会连接到ip为 127.0.0.1 端口号为 27017 的MongoDB服务上，并备份所有数据到 bin/dump/ 目录中。


        mongodump 命令可选参数列表如下所示：
            语法  描述  实例
            mongodump --host HOST_NAME --port PORT_NUMBER   该命令将备份所有MongoDB数据   mongodump --host w3cschool.cc --port 27017
            mongodump --dbpath DB_PATH --out BACKUP_DIRECTORY  无     mongodump --dbpath /data/db/ --out /data/backup/
            mongodump --collection COLLECTION --db DB_NAME  该命令将备份指定数据库的集合。 mongodump --collection mycol --db test



        MongoDB数据恢复：
            mongodb使用 'mongorestore'命令来恢复备份的数据。

            语法:
            mongorestore命令脚本语法如下：
                >mongorestore -h <hostname><:port> -d dbname <path>
                --host <:port>, -h <:port>：
                MongoDB所在服务器地址，默认为： localhost:27017
                --db , -d ：
                需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2
                --drop：
                恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！
                <path>：
                mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。
                你不能同时指定 <path> 和 --dir 选项，--dir也可以设置备份目录。
                --dir：
                指定备份的目录
                你不能同时指定 <path> 和 --dir 选项。

            接下来我们执行以下命令:
            >mongorestore




    MongoDB 监控:
        在你已经安装部署并允许MongoDB服务后，你必须要了解MongoDB的运行情况，并查看MongoDB的性能。这样在大流量得情况下可以很好的应对并保证MongoDB正常运作。
        MongoDB中提供了m'ongostat' 和 'mongotop' 两个命令来监控MongoDB的运行情况。

        mongostat 命令:
            mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。
                启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongostat命令，如下所示：
                D:\set up\mongodb\bin>mongostat


        mongotop 命令:
            mongotop也是mongodb下的一个内置工具，mongotop提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据。默认情况下，mongotop返回值的每一秒。
                启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongotop命令，如下所示：
                D:\set up\mongodb\bin>mongotop

                带参数实例
                 E:\mongodb-win32-x86_64-2.2.1\bin>mongotop 10

                 后面的10是<sleeptime>参数，可以不使用，等待的时间长度，以秒为单位，mongotop等待调用之间。
                 通过的默认mongotop返回数据的每一秒。


                E:\mongodb-win32-x86_64-2.2.1\bin>mongotop --locks
                报告每个数据库的锁的使用中，使用mongotop - 锁，这将产生以下输出：
                输出结果字段说明：
                     ns：
                     包含数据库命名空间，后者结合了数据库名称和集合。
                     db：
                     包含数据库的名称。名为 . 的数据库针对全局锁定，而非特定数据库。
                     total：
                     mongod花费的时间工作在这个命名空间提供总额。
                     read：
                     提供了大量的时间，这mongod花费在执行读操作，在此命名空间。
                     write：
                     提供这个命名空间进行写操作，这mongod花了大量的时间。


    Node.js 连接 MongoDB:
        本教程使用了淘宝定制的 cnpm 命令进行安装：
        $ cnpm install mongodb


        插入数据:
            var MongoClient = require('mongodb').MongoClient;
            var DB_CONN_STR = 'mongodb://localhost:27017/runoob'; # 数据库为 runoob

            var insertData = function(db, callback) {
                //连接到表 site
                var collection = db.collection('site');
                //插入数据
                var data = [{"name":"菜鸟教程","url":"www.runoob.com"},{"name":"菜鸟工具","url":"c.runoob.com"}];
                collection.insert(data, function(err, result) {
                    if(err)
                    {
                        console.log('Error:'+ err);
                        return;
                    }
                    callback(result);
                });
            }

            MongoClient.connect(DB_CONN_STR, function(err, db) {
                console.log("连接成功！");
                insertData(db, function(result) {
                    console.log(result);
                    db.close();
                });
            });


        查询数据
            var MongoClient = require('mongodb').MongoClient;
            var DB_CONN_STR = 'mongodb://localhost:27017/runoob';

            var selectData = function(db, callback) {
              //连接到表
              var collection = db.collection('site');
              //查询数据
              var whereStr = {"name":'菜鸟教程'};
              collection.find(whereStr).toArray(function(err, result) {
                if(err)
                {
                  console.log('Error:'+ err);
                  return;
                }
                callback(result);
              });
            }

            MongoClient.connect(DB_CONN_STR, function(err, db) {
              console.log("连接成功！");
              selectData(db, function(result) {
                console.log(result);
                db.close();
              });
            });


        更新数据:
            var MongoClient = require('mongodb').MongoClient;
            var DB_CONN_STR = 'mongodb://localhost:27017/runoob';

            var updateData = function(db, callback) {
                //连接到表
                var collection = db.collection('site');
                //更新数据
                var whereStr = {"name":'菜鸟教程'};
                var updateStr = {$set: { "url" : "https://www.runoob.com" }};
                collection.update(whereStr,updateStr, function(err, result) {
                    if(err)
                    {
                        console.log('Error:'+ err);
                        return;
                    }
                    callback(result);
                });
            }

            MongoClient.connect(DB_CONN_STR, function(err, db) {
                console.log("连接成功！");
                updateData(db, function(result) {
                    console.log(result);
                    db.close();
                });
            });


        删除数据:
            var MongoClient = require('mongodb').MongoClient;
            var DB_CONN_STR = 'mongodb://localhost:27017/runoob';

            var delData = function(db, callback) {
              //连接到表
              var collection = db.collection('site');
              //删除数据
              var whereStr = {"name":'菜鸟工具'};
              collection.remove(whereStr, function(err, result) {
                if(err)
                {
                  console.log('Error:'+ err);
                  return;
                }
                callback(result);
              });
            }

            MongoClient.connect(DB_CONN_STR, function(err, db) {
              console.log("连接成功！");
              delData(db, function(result) {
                console.log(result);
                db.close();
              });
            });



    MongoDB 关系
        MongoDB 的关系表示多个文档之间在逻辑上的相互联系。
        文档间可以通过嵌入和引用来建立联系。
            MongoDB 中的关系可以是：
                1:1 (1对1)
                1: N (1对多)
                N: 1 (多对1)
                N: N (多对多)
        接下来我们来考虑下用户与用户地址的关系。
        一个用户可以有多个地址，所以是一对多的关系。

        嵌入式关系:
            使用嵌入式方法，我们可以把用户地址嵌入到用户的文档中：
               "_id":ObjectId("52ffc33cd85242f436000001"),
               "contact": "987654321",
               "dob": "01-01-1991",
               "name": "Tom Benzamin",
               "address": [
                  {
                     "building": "22 A, Indiana Apt",
                     "pincode": 123456,
                     "city": "Los Angeles",
                     "state": "California"
                  },
                  {
                     "building": "170 A, Acropolis Apt",
                     "pincode": 456789,
                     "city": "Chicago",
                     "state": "Illinois"
                  }]
            }
        以上数据保存在单一的文档中，可以比较容易的获取和维护数据。 你可以这样查询用户的地址：
            >db.users.findOne({"name":"Tom Benzamin"},{"address":1})

        这种数据结构的缺点是，如果用户和用户地址在不断增加，数据量不断变大，会影响读写性能。


        引用式关系:
            引用式关系是设计数据库时经常用到的方法，这种方法把用户数据文档和用户地址数据文档分开，通过引用文档的 id 字段来建立关系。
            {
               "_id":ObjectId("52ffc33cd85242f436000001"),
               "contact": "987654321",
               "dob": "01-01-1991",
               "name": "Tom Benzamin",
               "address_ids": [
                  ObjectId("52ffc4a5d85242602e000000"),
                  ObjectId("52ffc4a5d85242602e000001")
               ]
            }
        以上实例中，用户文档的 address_ids 字段包含用户地址的对象id（ObjectId）数组。
        我们可以读取这些用户地址的对象id（ObjectId）来获取用户的详细地址信息。
        这种方法需要两次查询，第一次查询用户地址的对象id（ObjectId），第二次通过查询的id获取用户的详细地址信息。
            >var result = db.users.findOne({"name":"Tom Benzamin"},{"address_ids":1})
            >var addresses = db.address.find({"_id":{"$in":result["address_ids"]}})



    MongoDB 数据库引用:
        MongoDB 引用有两种：
            手动引用（Manual References）
            DBRefs

        DBRefs vs 手动引用
            考虑这样的一个场景，我们在不同的集合中 (address_home, address_office, address_mailing, 等)存储不同的地址（住址，办公室地址，邮件地址等）。
            这样，我们在调用不同地址时，也需要指定集合，一个文档从多个集合引用文档，我们应该使用 DBRefs。


            DBRef的形式：
                { $ref : , $id : , $db :  }
            三个字段表示的意义为：
                $ref：集合名称
                $id：引用的id
                $db:数据库名称，可选参数

            以下实例中用户数据文档使用了 DBRef, 字段 address：
                {
                   "_id":ObjectId("53402597d852426020000002"),
                   "address": {
                       "$ref": "address_home",
                       "$id": ObjectId("534009e4d852427820000002"),
                       "$db": "w3cschoolcc"
                    },
                   "contact": "987654321",
                   "dob": "01-01-1991",
                   "name": "Tom Benzamin"
                }
        address DBRef 字段指定了引用的地址文档是在 address_home 集合下的 w3cschoolcc 数据库，id 为 534009e4d852427820000002。
        以下代码中，我们通过指定 $ref 参数（address_home 集合）来查找集合中指定id的用户地址信息：
            >var user = db.users.findOne({"name":"Tom Benzamin"})
            >var dbRef = user.address
            >db[dbRef.$ref].findOne({"_id":(dbRef.$id)})

        以上实例返回了 address_home 集合中的地址数据：
            {
               "_id" : ObjectId("534009e4d852427820000002"),
               "building" : "22 A, Indiana Apt",
               "pincode" : 123456,
               "city" : "Los Angeles",
               "state" : "California"
            }



    MongoDB 覆盖索引查询
        官方的MongoDB的文档中说明，覆盖查询是以下的查询：
            所有的查询字段是索引的一部分
            所有的查询返回字段在同一个索引中
            由于所有出现在查询中的字段是索引的一部分， MongoDB 无需在整个数据文档中检索匹配查询条件和返回使用相同索引的查询结果。
            因为索引存在于RAM中，从索引中获取数据比通过扫描文档读取数据要快得多。

        使用覆盖索引查询
        为了测试盖索引查询，使用以下 users 集合:
            {
               "_id": ObjectId("53402597d852426020000002"),
               "contact": "987654321",
               "dob": "01-01-1991",
               "gender": "M",
               "name": "Tom Benzamin",
               "user_name": "tombenzamin"
            }
        我们在 users 集合中创建联合索引，字段为 gender 和 user_name :
            >db.users.ensureIndex({gender:1,user_name:1})
        现在，该索引会覆盖以下查询：
            >db.users.find({gender:"M"},{user_name:1,_id:0})
        也就是说，对于上述查询，MongoDB的不会去数据库文件中查找。相反，它会从索引中提取数据，这是非常快速的数据查询。

        由于我们的索引中不包括 _id 字段，_id在查询中会默认返回，我们可以在MongoDB的查询结果集中排除它。
        下面的实例没有排除_id，查询就不会被覆盖：
            >db.users.find({gender:"M"},{user_name:1})

        最后，如果是以下的查询，不能使用覆盖索引查询：
            所有索引字段是一个数组
            所有索引字段是一个子文档





    MongoDB 查询分析
        MongoDB 查询分析可以确保我们建议的索引是否有效，是查询语句性能分析的重要工具。
        MongoDB 查询分析常用函数有：explain() 和 hint()。

        使用 explain():
            explain 操作提供了查询信息，使用索引及查询统计等。有利于我们对索引的优化。
                接下来我们在 users 集合中创建 gender 和 user_name 的索引：
                >db.users.ensureIndex({gender:1,user_name:1})

            现在在查询语句中使用 explain ：
                >db.users.find({gender:"M"},{user_name:1,_id:0}).explain()

            以上的 explain() 查询返回如下结果：
                {
                   "cursor" : "BtreeCursor gender_1_user_name_1",
                   "isMultiKey" : false,
                   "n" : 1,
                   "nscannedObjects" : 0,
                   "nscanned" : 1,
                   "nscannedObjectsAllPlans" : 0,
                   "nscannedAllPlans" : 1,
                   "scanAndOrder" : false,
                   "indexOnly" : true,
                   "nYields" : 0,
                   "nChunkSkips" : 0,
                   "millis" : 0,
                   "indexBounds" : {
                      "gender" : [
                         [
                            "M",
                            "M"
                         ]
                      ],
                      "user_name" : [
                         [
                            {
                               "$minElement" : 1
                            },
                            {
                               "$maxElement" : 1
                            }
                         ]
                      ]
                   }
                }

            现在，我们看看这个结果集的字段：
                indexOnly: 字段为 true ，表示我们使用了索引。
                cursor：因为这个查询使用了索引，MongoDB 中索引存储在B树结构中，所以这是也使用了 BtreeCursor 类型的游标。如果没有使用索引，游标的类型是 BasicCursor。这个键还会给出你所使用的索引的名称，你通过这个名称可以查看当前数据库下的system.indexes集合（系统自动创建，由于存储索引信息，这个稍微会提到）来得到索引的详细信息。
                n：当前查询返回的文档数量。
                nscanned/nscannedObjects：表明当前这次查询一共扫描了集合中多少个文档，我们的目的是，让这个数值和返回文档的数量越接近越好。
                millis：当前查询所需时间，毫秒数。
                indexBounds：当前查询具体使用的索引。


        使用 hint():
            虽然MongoDB查询优化器一般工作的很不错，但是也可以使用 hint 来强制 MongoDB 使用一个指定的索引。
            这种方法某些情形下会提升性能。 一个有索引的 collection 并且执行一个多字段的查询(一些字段已经索引了)。

            如下查询实例指定了使用 gender 和 user_name 索引字段来查询：
                >db.users.find({gender:"M"},{user_name:1,_id:0}).hint({gender:1,user_name:1})

            可以使用 explain() 函数来分析以上查询：
                >db.users.find({gender:"M"},{user_name:1,_id:0}).hint({gender:1,user_name:1}).explain()




MongoDB 原子操作:
        mongodb不支持事务，所以，在你的项目中应用时，要注意这点。
        无论什么设计，都不要要求mongodb保证数据的完整性。
        但是mongodb提供了许多原子操作，比如文档的保存，修改，删除等，都是原子操作。
        所谓原子操作就是要么这个文档保存到Mongodb，要么没有保存到Mongodb，不会出现查询到的文档没有保存完整的情况。


        原子操作常用命令
            $set：
            用来指定一个键并更新键值，若键不存在并创建。
            { $set : { field : value } }

            $unset：
            用来删除一个键。
            { $unset : { field : 1} }

            $inc：
            $inc可以对文档的某个值为'数字型'（只能为满足要求的数字）的键进行增减的操作。
            { $inc : { field : value } }

            $push：
            用法：
            { $push : { field : value } }
            把value追加到field里面去，field一定要是'数组类型'才行，如果field不存在，会新增一个数组类型加进去。

            $pushAll：
            同$push,只是一次可以追加多个值到一个'数组'字段内。
            { $pushAll : { field : value_array } }

            $pull：
            从'数组'field内删除一个等于value值。
            { $pull : { field : _value } }

            $addToSet：
            增加一个值到 '数组' 内，而且只有当这个值 不在数组内 才增加。

            $pop：
            删除'数组'的第一个或最后一个元素
            { $pop : { field : 1 } }

            $rename：
            修改字段名称
            { $rename : { old_field_name : new_field_name } }

            $bit：
            位操作，integer类型
            {$bit : { field : {and : 5}}}



MongoDB 高级索引

        示例文档：
            {
               "address": {
                  "city": "Los Angeles",
                  "state": "California",
                  "pincode": "123"
               },
               "tags": [
                  "music",
                  "cricket",
                  "blogs"
               ],
               "name": "Tom Benzamin"
            }

        索引数组字段:
            假设我们基于标签来检索用户，为此我们需要对集合中的数组 tags 建立索引。
            在数组中创建索引，需要对数组中的每个字段依次建立索引。所以在我们为数组 tags 创建索引时，会为 music、cricket、blogs三个值建立单独的索引。
                使用以下命令创建数组索引：
                    >db.users.ensureIndex({"tags":1})
                创建索引后，我们可以这样检索集合的 tags 字段：
                    >db.users.find({tags:"cricket"})
                为了验证我们使用使用了索引，可以使用 explain 命令：
                    >db.users.find({tags:"cricket"}).explain()
                以上命令执行结果中会显示 "cursor" : "BtreeCursor tags_1" ，则表示已经使用了索引。


        索引子文档字段:
            假设我们需要通过city、state、pincode字段来检索文档，由于这些字段是子文档的字段，所以我们需要对子文档建立索引。
            为子文档的三个字段创建索引，命令如下：
                >db.users.ensureIndex({"address.city":1,"address.state":1,"address.pincode":1})
            一旦创建索引，我们可以使用子文档的字段来检索数据：
                >db.users.find({"address.city":"Los Angeles"})
            记住查询表达式必须遵循指定的索引的顺序。所以上面创建的索引将支持以下查询：
                >db.users.find({"address.city":"Los Angeles","address.state":"California"})
            同样支持以下查询：
                >db.users.find({"address.city":"LosAngeles","address.state":"California","address.pincode":"123"})



    MongoDB 索引限制:

        额外开销:
            每个索引占据一定的存储空间，在进行插入，更新和删除操作时也需要对索引进行操作。所以，如果你很少对集合进行读取操作，建议不使用索引。

        内存(RAM)使用:
            由于索引是存储在内存(RAM)中,你应该确保该索引的大小不超过内存的限制。
            如果索引的大小大于内存的限制，MongoDB会删除一些索引，这将导致性能下降。

        查询限制:
            索引不能被以下的查询使用：
                正则表达式及非操作符，如 $nin, $not, 等。
                算术运算符，如 $mod, 等。
                $where 子句
                所以，检测你的语句是否使用索引是一个好的习惯，可以用explain来查看。


        索引键限制
            从2.6版本开始，如果现有的索引字段的值超过索引键的限制，MongoDB中不会创建索引。

            插入文档超过索引键限制:
                如果文档的索引字段值超过了索引键的限制，MongoDB不会将任何文档转换成索引的集合。与mongorestore和mongoimport工具类似。
            索引最大范围:
                集合中索引不能超过64个
                索引名的长度不能超过128个字符
                一个复合索引最多可以有31个字段




MongoDB ObjectId:
        ObjectId 是一个12字节 BSON 类型数据，有以下格式：
            前4个字节表示时间戳
            接下来的3个字节是机器标识码
            紧接的两个字节由进程id组成（PID）
            最后三个字节是随机数。

        MongoDB中存储的文档必须有一个"_id"键。这个键的值可以是任何类型的，默认是个ObjectId对象。

        在一个集合里面，每个文档都有唯一的"_id"值，来确保集合里面每个文档都能被唯一标识。

        MongoDB采用ObjectId，而不是其他比较常规的做法（比如自动增加的主键）的主要原因，因为在多个 服务器上同步自动增加主键值既费力还费时。

        创建新的ObjectId:
            使用以下代码生成新的ObjectId：
                >newObjectId = ObjectId()
                上面的语句返回以下唯一生成的id：
                ObjectId("5349b4ddd2781d08c09890f3")
                你也可以使用生成的id来取代MongoDB自动生成的ObjectId：
                >myObjectId = ObjectId("5349b4ddd2781d08c09890f4")

        创建文档的时间戳:
            由于 ObjectId 中存储了 4 个字节的时间戳，所以你不需要为你的文档保存时间戳字段，你可以通过 getTimestamp 函数来获取文档的创建时间:
                >ObjectId("5349b4ddd2781d08c09890f4").getTimestamp()
                以上代码将返回 ISO 格式的文档创建时间：
                ISODate("2014-04-12T21:49:17Z")

        ObjectId 转换为字符串:
            在某些情况下，您可能需要将ObjectId转换为字符串格式。你可以使用下面的代码：
                >new ObjectId().str
                以上代码将返回Guid格式的字符串：：
                5349b4ddd2781d08c09890f3



MongoDB Map Reduce:
    Map-Reduce是一种计算模型，简单的说就是将大批量的工作（数据）分解（MAP）执行，然后再将结果合并成最终结果（REDUCE）。
    MongoDB提供的Map-Reduce非常灵活，对于大规模数据分析也相当实用。

    MapReduce 命令
        以下是MapReduce的基本语法：
            >db.collection.mapReduce(
               function() {emit(key,value);},  //map 函数
               function(key,values) {return reduceFunction},   //reduce 函数
               {
                  out: collection,
                  query: document,
                  sort: document,
                  limit: number
               }
            )

        使用 MapReduce 要实现两个函数 Map 函数和 Reduce 函数
        Map 函数调用 emit(key, value), 遍历 collection 中所有的记录, 将 key 与 value 传递给 Reduce 函数进行处理。
        Map 函数必须调用 emit(key, value) 返回键值对。

        参数说明:
            map ：映射函数 (生成键值对序列,作为 reduce 函数参数)。
            reduce： 统计函数，reduce函数的任务就是将key-values变成key-value，也就是把values数组变成一个单一的值value。。
            out： 统计结果存放集合 (不指定则使用临时集合,在客户端断开后自动删除)。
            query： 一个筛选条件，只有满足条件的文档才会调用map函数。（query。limit，sort可以随意组合）
            sort： 和limit结合的sort排序参数（也是在发往map函数前给文档排序），可以优化分组机制
            limit： 发往map函数的文档数量的上限（要是没有limit，单独使用sort的用处不大）


        现在，我们将在 posts 集合中使用 mapReduce 函数来选取已发布的文章(status:"active")，并通过user_name分组，计算每个用户的文章数：
                >db.posts.mapReduce(
                   function() { emit(this.user_name,1); },
                   function(key, values) {return Array.sum(values)},
                      {
                         query:{status:"active"},
                         out:"post_total"
                      }
                )
            以上 mapReduce 输出结果为：
                {
                        "result" : "post_total",
                        "timeMillis" : 23,
                        "counts" : {
                                "input" : 5,
                                "emit" : 5,
                                "reduce" : 1,
                                "output" : 2
                        },
                        "ok" : 1
                }
        结果表明，共有 5 个符合查询条件（status:"active"）的文档， 在map函数中生成了 5 个键值对文档，最后使用reduce函数将相同的键值分为 2 组。

            具体参数说明：
                result：储存结果的collection的名字,这是个临时集合，MapReduce的连接关闭后自动就被删除了。
                timeMillis：执行花费的时间，毫秒为单位
                input：满足条件被发送到map函数的文档个数
                emit：在map函数中emit被调用的次数，也就是所有集合中的数据总量
                ouput：结果集合中的文档个数（count对调试非常有帮助）
                ok：是否成功，成功为1
                err：如果失败，这里可以有失败原因，不过从经验上来看，原因比较模糊，作用不大

                使用 find 操作符来查看 mapReduce 的查询结果：
                >db.posts.mapReduce(
                   function() { emit(this.user_name,1); },
                   function(key, values) {return Array.sum(values)},
                      {
                         query:{status:"active"},
                         out:"post_total"
                      }
                ).find()
                以上查询显示如下结果，两个用户 tom 和 mark 有两个发布的文章:
                    { "_id" : "mark", "value" : 4 }
                    { "_id" : "runoob", "value" : 1 }
                用类似的方式，MapReduce可以被用来构建大型复杂的聚合查询。
                Map函数和Reduce函数可以使用 JavaScript 来实现，使得MapReduce的使用非常灵活和强大。


    MongoDB 全文检索:
        全文检索对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。
        这个过程类似于通过字典中的检索字表查字的过程。
        MongoDB 从 2.4 版本开始支持全文检索，目前支持15种语言(暂时不支持中文)的全文索引。

        创建全文索引
        考虑以下 posts 集合的文档数据，包含了文章内容（post_text）及标签(tags)：
            {
               "post_text": "enjoy the mongodb articles on Runoob",
               "tags": [
                  "mongodb",
                  "runoob"
               ]
            }
        我们可以对 post_text 字段建立全文索引，这样我们可以搜索文章内的内容：
            >db.posts.ensureIndex({post_text:"text"})


        使用全文索引
        现在我们已经对 post_text 建立了全文索引，我们可以搜索文章中的关键词 runoob：
            >db.posts.find({$text:{$search:"runoob"}})
        以下命令返回了如下包含 runoob 关键词的文档数据：
            {
               "_id" : ObjectId("53493d14d852429c10000002"),
               "post_text" : "enjoy the mongodb articles on Runoob",
               "tags" : [ "mongodb", "runoob" ]
            }
        如果你使用的是旧版本的 MongoDB，你可以使用以下命令：
            >db.posts.runCommand("text",{search:"runoob"})
        使用全文索引可以提高搜索效率。


        删除全文索引
        删除已存在的全文索引，可以使用 find 命令查找索引名：
            >db.posts.getIndexes()
        通过以上命令获取索引名，本例的索引名为post_text_text，执行以下命令来删除索引：
            >db.posts.dropIndex("post_text_text")



MongoDB 正则表达式:
    正则表达式是使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。
    许多程序设计语言都支持利用正则表达式进行字符串操作。
    MongoDB 使用 $regex 操作符来设置匹配字符串的正则表达式。
    MongoDB使用PCRE (Perl Compatible Regular Expression) 作为正则表达式语言。
    不同于全文检索，我们使用正则表达式不需要做任何配置。

    使用正则表达式
        以下命令使用正则表达式查找包含 runoob 字符串的文章：
        >db.posts.find({post_text:{$regex:"runoob"}})

        以上查询也可以写为：
        >db.posts.find({post_text:/runoob/})

        不区分大小写的正则表达式
        如果检索需要不区分大小写，我们可以设置 $options 为 $i。
        以下命令将查找不区分大小写的字符串 runoob：
        >db.posts.find({post_text:{$regex:"runoob",$options:"$i"}})

        集合中会返回所有包含字符串 runoob 的数据，且不区分大小写：
        {
           "_id" : ObjectId("53493d37d852429c10000004"),
           "post_text" : "hey! this is my post on  runoob",
           "tags" : [ "runoob" ]
        }

        数组元素使用正则表达式
            我们还可以在数组字段中使用正则表达式来查找内容。 这在标签的实现上非常有用，如果你需要查找包含以 run 开头的标签数据(ru 或 run 或 runoob)， 你可以使用以下代码：
            >db.posts.find({tags:{$regex:"run"}})

        优化正则表达式查询
            如果你的文档中字段设置了索引，那么使用索引相比于正则表达式匹配查找所有的数据查询速度更快。
            如果正则表达式是前缀表达式，所有匹配的数据将以指定的前缀字符串为开始。例如： 如果正则表达式为 ^tut ，查询语句将查找以 tut 为开头的字符串。
            这里面使用正则表达式有两点需要注意：
            正则表达式中使用变量。一定要使用eval将组合的字符串进行转换，不能直接将字符串拼接后传入给表达式。否则没有报错信息，只是结果为空！实例如下：
                var name=eval("/" + 变量值key +"/i");
            以下是模糊查询包含title关键词, 且不区分大小写:
                title:eval("/"+title+"/i")    // 等同于 title:{$regex:title,$Option:"$i"}




    MongoDB GridFS：
        GridFS 用于存储和恢复那些超过16M（BSON文件限制）的文件(如：图片、音频、视频等)。
        GridFS 也是文件存储的一种方式，但是它是存储在MonoDB的集合中。
        GridFS 可以更好的存储大于16M的文件。
        GridFS 会将大文件对象分割成多个小的chunk(文件片段),一般为256k/个,每个chunk将作为MongoDB的一个文档(document)被存储在chunks集合中。

        GridFS 用两个集合来存储一个文件：fs.files与fs.chunks。
        每个文件的实际内容被存在chunks(二进制数据)中,和文件有关的meta数据(filename,content_type,还有用户自定义的属性)将会被存在files集合中。
            以下是简单的 fs.files 集合文档：
                {
                   "filename": "test.txt",
                   "chunkSize": NumberInt(261120),
                   "uploadDate": ISODate("2014-04-13T11:32:33.557Z"),
                   "md5": "7b762939321e146569b07f72c62cca4f",
                   "length": NumberInt(646)
                }
            以下是简单的 fs.chunks 集合文档：
                {
                   "files_id": ObjectId("534a75d19f54bfec8a2fe44b"),
                   "n": NumberInt(0),
                   "data": "Mongo Binary Data"
                }
                GridFS 添加文件

        现在我们使用 GridFS 的 put 命令来存储 mp3 文件。 调用 MongoDB 安装目录下bin的 mongofiles.exe工具。
        打开命令提示符，进入到MongoDB的安装目录的bin目录中，找到mongofiles.exe，并输入下面的代码：
            >mongofiles.exe -d gridfs put song.mp3

        GridFS 是存储文件的数据名称。如果不存在该数据库，MongoDB会自动创建。Song.mp3 是音频文件名。
        使用以下命令来查看数据库中文件的文档：
            >db.fs.files.find()

        以上命令执行后返回以下文档数据：
            {
               _id: ObjectId('534a811bf8b4aa4d33fdf94d'),
               filename: "song.mp3",
               chunkSize: 261120,
               uploadDate: new Date(1397391643474), md5: "e4f53379c909f7bed2e9d631e15c1c41",
               length: 10401959
            }

        我们可以看到 fs.chunks 集合中所有的区块，以下我们得到了文件的 _id 值，我们可以根据这个 _id 获取区块(chunk)的数据：
            >db.fs.chunks.find({files_id:ObjectId('534a811bf8b4aa4d33fdf94d')})
            以上实例中，查询返回了 40 个文档的数据，意味着mp3文件被存储在40个区块中。





    MongoDB 固定集合：
        MongoDB 固定集合（Capped Collections）是性能出色且有着固定大小的集合，对于大小固定，我们可以想象其就像一个环形队列，当集合空间用完后，再插入的元素就会覆盖最初始的头部的元素！

        创建固定集合：
            我们通过createCollection来创建一个固定集合，且capped选项设置为true：
                >db.createCollection("cappedLogCollection",{capped:true,size:10000})

            还可以指定文档个数,加上max:1000属性：
                >db.createCollection("cappedLogCollection",{capped:true,size:10000,max:1000})

            判断集合是否为固定集合:
                >db.cappedLogCollection.isCapped()

            如果需要将已存在的集合转换为固定集合可以使用以下命令：
                >db.runCommand({"convertToCapped":"posts",size:10000})
            以上代码将我们已存在的 posts 集合转换为固定集合。


        固定集合查询：
            固定集合文档按照插入顺序储存的,默认情况下查询就是按照插入顺序返回的,也可以使用$natural调整返回顺序。
            >db.cappedLogCollection.find().sort({$natural:-1})

        固定集合的功能特点：
            可以插入及更新,但更新不能超出collection的大小,否则更新失败,不允许删除,但是可以调用drop()删除集合中的所有行,但是drop后需要显式地重建集合。
            在32位机子上一个cappped collection的最大值约为482.5M,64位上只受系统文件大小的限制。

        固定集合属性及用法：
            属性：
                属性1:对固定集合进行插入速度极快
                属性2:按照插入顺序的查询输出速度极快
                属性3:能够在插入最新数据时,淘汰最早的数据
            用法：
                用法1:储存日志信息
                用法2:缓存一些少量的文档



    MongoDB 自动增长:
        MongoDB 没有像 SQL 一样有自动增长的功能， MongoDB 的 _id 是系统自动生成的12字节唯一标识。
        但在某些情况下，我们可能需要实现 ObjectId 自动增长功能。
        由于 MongoDB 没有实现这个功能，我们可以通过编程的方式来实现


        创建 counters 集合，序列字段值可以实现自动长：
            >db.createCollection("counters")

        使用以下命令将文档插入 counters 集合中：
            >db.counters.insert({_id:"productid",sequence_value:0})

        创建 Javascript 函数：
            现在，我们创建函数 getNextSequenceValue 来作为序列名的输入， 指定的序列会自动增长 1 并返回最新序列值。在本文的实例中序列名为 productid 。
                >function getNextSequenceValue(sequenceName){
                   var sequenceDocument = db.counters.findAndModify(
                      {
                         query:{_id: sequenceName },
                         update: {$inc:{sequence_value:1}},
                         new:true
                      });
                   return sequenceDocument.sequence_value;
                }

        使用 Javascript 函数：
            接下来我们将使用 getNextSequenceValue 函数创建一个新的文档， 并设置文档 _id 自动为返回的序列值：
                >db.products.insert({
                   "_id":getNextSequenceValue("productid"),
                   "product_name":"Apple iPhone",
                   "category":"mobiles"})

                >db.products.insert({
                   "_id":getNextSequenceValue("productid"),
                   "product_name":"Samsung S3",
                   "category":"mobiles"})
                就如你所看到的，我们使用 getNextSequenceValue 函数来设置 _id 字段。

        为了验证函数是否有效，我们可以使用以下命令读取文档：
            >db.products.find()
            以上命令将返回以下结果，我们发现 _id 字段是自增长的：
                { "_id" : 1, "product_name" : "Apple iPhone", "category" : "mobiles"}
                { "_id" : 2, "product_name" : "Samsung S3", "category" : "mobiles" }
